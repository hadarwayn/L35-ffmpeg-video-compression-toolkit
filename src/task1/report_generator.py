"""
Human-readable summary report for Task 1.

Combines metadata, GOP analysis, and frame statistics into a
plain-English text file that a non-technical person can understand.
"""

import logging
from pathlib import Path
from typing import Any

import numpy as np
import pandas as pd

logger = logging.getLogger("task1.report")


def generate_report(
    metadata: dict[str, Any],
    gop_info: dict[str, Any],
    frame_df: pd.DataFrame,
    output_dir: Path,
) -> None:
    """Write ``summary_report.txt`` to *output_dir*."""
    lines: list[str] = []
    _header(lines)
    _video_props(lines, metadata)
    _gop_section(lines, gop_info)
    _frame_counts(lines, gop_info)
    _iframe_stats(lines, gop_info)
    _key_findings(lines, metadata, gop_info, frame_df)

    report_path = output_dir / "summary_report.txt"
    report_path.write_text("\n".join(lines), encoding="utf-8")
    logger.info("Saved summary_report.txt")


def _header(lines: list[str]) -> None:
    """Add the report title banner."""
    lines.append("=" * 60)
    lines.append("  VIDEO ANALYSIS SUMMARY REPORT")
    lines.append("  Generated by L35 Video Compression Toolkit")
    lines.append("=" * 60)
    lines.append("")


def _video_props(lines: list[str], meta: dict) -> None:
    """Format video and container properties as a readable table."""
    v = meta["video"]
    c = meta["container"]
    lines.append("--- Video Properties ---")
    lines.append(f"  Resolution:    {v['width']}x{v['height']}")
    lines.append(f"  Frame Rate:    {v['fps']} fps")
    lines.append(f"  Codec:         {v['codec_name']} (profile: {v['profile']})")
    lines.append(f"  Pixel Format:  {v['pix_fmt']}")
    lines.append(f"  Duration:      {c['duration_sec']:.2f} seconds")
    lines.append(f"  File Size:     {c['file_size_bytes'] / 1_048_576:.2f} MB")
    lines.append(f"  Bitrate:       {c['bitrate_kbps']:.0f} kbps")

    if meta.get("audio"):
        a = meta["audio"]
        lines.append(f"\n  Audio:         {a['codec_name']}, "
                      f"{a['sample_rate']} Hz, {a['channels']}ch")
    lines.append("")


def _gop_section(lines: list[str], gop: dict) -> None:
    """Append GOP pattern, average length, and fixed/variable indicator."""
    lines.append("--- GOP Structure ---")
    lines.append(f"  Pattern:       {gop['gop_pattern'][:40]}")
    lines.append(f"  Avg length:    {gop['avg_gop_length']} frames")
    lines.append(f"  Fixed GOP:     {'Yes' if gop['is_fixed_gop'] else 'No (variable)'}")
    lines.append("")


def _frame_counts(lines: list[str], gop: dict) -> None:
    """Append I/P/B frame counts with percentages."""
    counts = gop["frame_counts"]
    total = gop["total_frames"]
    lines.append("--- Frame Type Distribution ---")
    for ftype in ["I", "P", "B"]:
        c = counts.get(ftype, 0)
        pct = c / total * 100 if total else 0
        lines.append(f"  {ftype}-frames:   {c:>6}  ({pct:.1f}%)")
    lines.append(f"  Total:       {total:>6}")
    lines.append("")


def _iframe_stats(lines: list[str], gop: dict) -> None:
    """Append I-frame size statistics (count, avg, min, max, std, interval)."""
    ist = gop.get("i_frame_stats", {})
    if not ist:
        return
    lines.append("--- I-Frame Statistics ---")
    lines.append(f"  Count:         {ist['count']}")
    lines.append(f"  Avg size:      {ist['avg_size_bytes']:.0f} bytes")
    lines.append(f"  Min size:      {ist['min_size_bytes']} bytes")
    lines.append(f"  Max size:      {ist['max_size_bytes']} bytes")
    lines.append(f"  Std deviation: {ist['std_size_bytes']:.0f} bytes")
    lines.append(f"  Avg interval:  {ist['avg_distance_frames']:.0f} frames "
                  f"({ist['avg_distance_sec']:.2f}s)")
    lines.append("")


def _key_findings(lines: list[str], meta: dict, gop: dict, df: pd.DataFrame) -> None:
    """Derive and append plain-English observations from the analysis data."""
    lines.append("--- Key Findings ---")
    sizes = gop.get("avg_size_by_type_bytes", {})
    if "I" in sizes and "P" in sizes:
        ratio = sizes["I"] / sizes["P"] if sizes["P"] else 0
        lines.append(f"  * I-frames are ~{ratio:.1f}x larger than P-frames, "
                      "confirming they carry full image data.")
    if "B" in sizes:
        lines.append(f"  * B-frames average only {sizes['B']:.0f} bytes "
                      "-- the most efficient frame type.")
    peak = gop.get("peak_bitrate", {})
    if peak:
        lines.append(f"  * Peak frame size at frame #{peak['frame_number']} "
                      f"({peak['timestamp_sec']}s): {peak['size_bytes']:,} bytes.")
    lines.append("")
    lines.append("=" * 60)
